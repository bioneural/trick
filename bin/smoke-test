#!/usr/bin/env bash

# smoke-test — end-to-end verification of every trick happy path
#
# Runs against a temporary directory so production data is never touched.
# Each test exercises one happy path and reports pass/fail.
#
# Usage:
#   bin/smoke-test
#
# Dependencies: bash, ruby, crib, ollama
#
# Behavior:
#   1. Creates a temporary directory for test artifacts
#   2. Creates a fake JSONL transcript
#   3. Runs each test in sequence
#   4. Cleans up the temporary directory
#   5. Exits 0 if all pass, 1 if any fail

set -uo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
TRICK="$SCRIPT_DIR/trick"

# Temporary directory for all test artifacts
TMPDIR_BASE=$(mktemp -d)
export CRIB_DB="$TMPDIR_BASE/test.db"
export TRICK_CLAUDE_DIR="$TMPDIR_BASE"

# Resolve crib
CRIB_HOME="${CRIB_HOME:-$(dirname "$(dirname "$SCRIPT_DIR")")/crib}"
export CRIB_HOME
CRIB="$CRIB_HOME/bin/crib"

cleanup() {
  rm -rf "$TMPDIR_BASE"
}
trap cleanup EXIT

passed=0
failed=0
failures=()

pass() {
  printf "  \033[32m✓\033[0m %s\n" "$1"
  ((passed++))
}

fail() {
  printf "  \033[31m✗\033[0m %s — %s\n" "$1" "$2"
  ((failed++))
  failures+=("$1")
}

section() {
  printf "\n\033[1m%s\033[0m\n" "$1"
}

# ---------------------------------------------------------------------------
# Create test transcript
# ---------------------------------------------------------------------------

TRANSCRIPT="$TMPDIR_BASE/test-transcript.jsonl"
cat > "$TRANSCRIPT" << 'JSONL'
{"type":"user","message":{"role":"user","content":"We should use Redis for caching. It handles our access patterns well."},"uuid":"aaa-001","timestamp":"2026-02-11T10:00:00Z","sessionId":"test-session-1"}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"text","text":"Redis is a solid choice for caching. Sub-millisecond reads and we can leverage the existing infrastructure."}]},"uuid":"aaa-002","timestamp":"2026-02-11T10:00:30Z","sessionId":"test-session-1"}
{"type":"user","message":{"role":"user","content":"Actually, switch to Memcached. Redis is overkill for simple key-value caching."},"uuid":"aaa-003","timestamp":"2026-02-11T10:01:00Z","sessionId":"test-session-1"}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"text","text":"Understood. Memcached is a better fit for simple key-value caching — less operational overhead. Switching now."}]},"uuid":"aaa-004","timestamp":"2026-02-11T10:01:30Z","sessionId":"test-session-1"}
JSONL

# Second transcript for cursor tests — extends the first with new turns
TRANSCRIPT_EXT="$TMPDIR_BASE/test-transcript-ext.jsonl"
cat "$TRANSCRIPT" > "$TRANSCRIPT_EXT"
cat >> "$TRANSCRIPT_EXT" << 'JSONL'
{"type":"user","message":{"role":"user","content":"Also, we decided to deploy on Fly.io instead of AWS. Simpler for our scale."},"uuid":"aaa-005","timestamp":"2026-02-11T10:02:00Z","sessionId":"test-session-1"}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"text","text":"Fly.io makes sense for a small team. Lower operational complexity than AWS."}]},"uuid":"aaa-006","timestamp":"2026-02-11T10:02:30Z","sessionId":"test-session-1"}
JSONL

# ---------------------------------------------------------------------------
section "Prerequisites"
# ---------------------------------------------------------------------------

test_crib_exists() {
  if [[ -x "$CRIB" ]]; then
    pass "crib found at $CRIB_HOME"
  else
    fail "crib" "not found — set CRIB_HOME"
  fi
}
test_crib_exists

test_ruby_syntax() {
  local bad=()
  for script in "$TRICK"; do
    ruby -c "$script" >/dev/null 2>&1 || bad+=("$(basename "$script")")
  done
  if [[ ${#bad[@]} -eq 0 ]]; then
    pass "Ruby scripts pass syntax check"
  else
    fail "Syntax errors" "${bad[*]}"
  fi
}
test_ruby_syntax

# ---------------------------------------------------------------------------
section "JSONL parsing"
# ---------------------------------------------------------------------------

test_parse_valid_transcript() {
  local output
  output=$(ruby -e '
    require "json"
    count = 0
    File.readlines(ARGV[0]).each do |line|
      entry = JSON.parse(line.strip) rescue next
      count += 1 if %w[user assistant].include?(entry["type"])
    end
    puts count
  ' "$TRANSCRIPT" 2>/dev/null)
  if [[ "$output" == "4" ]]; then
    pass "JSONL parser finds 4 conversation turns"
  else
    fail "JSONL parse" "expected 4 turns, got: $output"
  fi
}
test_parse_valid_transcript

test_parse_mixed_content() {
  # Assistant messages have array content (content blocks), user messages have string content
  local output
  output=$(ruby -rjson -e '
    File.readlines(ARGV[0]).each do |line|
      entry = JSON.parse(line.strip) rescue next
      msg = entry["message"]
      content = msg["content"]
      if content.is_a?(Array)
        text = content.select { |b| b["type"] == "text" }.map { |b| b["text"] }.join
        puts "array:#{text.length > 0}"
      elsif content.is_a?(String)
        puts "string:#{content.length > 0}"
      end
    end
  ' "$TRANSCRIPT" 2>/dev/null)
  if echo "$output" | grep -q "string:true" && echo "$output" | grep -q "array:true"; then
    pass "Parser handles both string and array content"
  else
    fail "Content parsing" "expected both string and array content types"
  fi
}
test_parse_mixed_content

test_empty_input() {
  local exit_code
  echo "" | "$TRICK" 2>/dev/null
  exit_code=$?
  if [[ $exit_code -eq 0 ]]; then
    pass "Empty input exits cleanly"
  else
    fail "Empty input" "expected exit 0, got $exit_code"
  fi
}
test_empty_input

test_invalid_jsonl() {
  local exit_code
  echo "this is not json" | "$TRICK" 2>/dev/null
  exit_code=$?
  if [[ $exit_code -eq 0 ]]; then
    pass "Invalid JSONL exits cleanly"
  else
    fail "Invalid JSONL" "expected exit 0, got $exit_code"
  fi
}
test_invalid_jsonl

test_file_flag() {
  local exit_code
  "$TRICK" --file "$TRANSCRIPT" 2>/dev/null
  exit_code=$?
  if [[ $exit_code -eq 0 ]]; then
    pass "File flag reads transcript"
  else
    fail "File flag" "expected exit 0, got $exit_code"
  fi
}
test_file_flag

test_missing_file() {
  local exit_code
  "$TRICK" --file "$TMPDIR_BASE/nonexistent.jsonl" 2>/dev/null
  exit_code=$?
  if [[ $exit_code -eq 0 ]]; then
    pass "Missing file exits cleanly"
  else
    fail "Missing file" "expected exit 0, got $exit_code"
  fi
}
test_missing_file

# ---------------------------------------------------------------------------
section "Cursor tracking"
# ---------------------------------------------------------------------------

# Reset cursor for these tests
rm -f "$TMPDIR_BASE/trick-cursor.json"

test_cursor_created() {
  # Run trick on the transcript — should create a cursor file
  "$TRICK" --file "$TRANSCRIPT" 2>/dev/null
  if [[ -f "$TMPDIR_BASE/trick-cursor.json" ]]; then
    pass "Cursor file created after reflection"
  else
    fail "Cursor" "file not created at $TMPDIR_BASE/trick-cursor.json"
  fi
}
test_cursor_created

test_cursor_has_last_uuid() {
  if [[ -f "$TMPDIR_BASE/trick-cursor.json" ]]; then
    local uuid
    uuid=$(ruby -rjson -e 'puts JSON.parse(File.read(ARGV[0]))["last_reflected_uuid"]' "$TMPDIR_BASE/trick-cursor.json" 2>/dev/null)
    if [[ "$uuid" == "aaa-004" ]]; then
      pass "Cursor points to last turn (aaa-004)"
    else
      fail "Cursor UUID" "expected aaa-004, got: $uuid"
    fi
  else
    fail "Cursor UUID" "cursor file missing"
  fi
}
test_cursor_has_last_uuid

test_cursor_skips_processed() {
  # Run trick again on the same transcript — should report no new turns
  local output
  output=$("$TRICK" --file "$TRANSCRIPT" 2>&1)
  if echo "$output" | grep -q "no new turns"; then
    pass "Cursor skips already-processed turns"
  else
    fail "Cursor skip" "expected 'no new turns', got: $output"
  fi
}
test_cursor_skips_processed

test_cursor_processes_new_turns() {
  # Run trick on the extended transcript — should process only the new turns
  local output
  output=$("$TRICK" --file "$TRANSCRIPT_EXT" 2>&1)
  if echo "$output" | grep -q "processing 2 turns"; then
    pass "Cursor processes only new turns"
  else
    # Might say "processing" with different count depending on extraction
    if echo "$output" | grep -q "processing"; then
      pass "Cursor processes new turns (count varies)"
    else
      fail "Cursor new turns" "expected 'processing' message, got: $output"
    fi
  fi
}
test_cursor_processes_new_turns

test_cursor_updated() {
  if [[ -f "$TMPDIR_BASE/trick-cursor.json" ]]; then
    local uuid
    uuid=$(ruby -rjson -e 'puts JSON.parse(File.read(ARGV[0]))["last_reflected_uuid"]' "$TMPDIR_BASE/trick-cursor.json" 2>/dev/null)
    if [[ "$uuid" == "aaa-006" ]]; then
      pass "Cursor updated to latest turn (aaa-006)"
    else
      fail "Cursor update" "expected aaa-006, got: $uuid"
    fi
  else
    fail "Cursor update" "cursor file missing"
  fi
}
test_cursor_updated

test_cursor_resets_on_new_session() {
  # Create a transcript with a different session ID
  local new_transcript="$TMPDIR_BASE/new-session.jsonl"
  cat > "$new_transcript" << 'JSONL'
{"type":"user","message":{"role":"user","content":"Starting a new project with Python and FastAPI."},"uuid":"bbb-001","timestamp":"2026-02-12T10:00:00Z","sessionId":"test-session-2"}
{"type":"assistant","message":{"role":"assistant","content":[{"type":"text","text":"Good stack. FastAPI gives you automatic OpenAPI docs and async support."}]},"uuid":"bbb-002","timestamp":"2026-02-12T10:00:30Z","sessionId":"test-session-2"}
JSONL

  local output
  output=$("$TRICK" --file "$new_transcript" 2>&1)
  if echo "$output" | grep -q "processing 2 turns"; then
    pass "Cursor resets on new session ID"
  else
    if echo "$output" | grep -q "processing"; then
      pass "Cursor resets on new session (count varies)"
    else
      fail "Cursor reset" "expected processing message, got: $output"
    fi
  fi
}
test_cursor_resets_on_new_session

# ---------------------------------------------------------------------------
section "Memory extraction"
# ---------------------------------------------------------------------------

# Reset cursor and crib DB for extraction tests
rm -f "$TMPDIR_BASE/trick-cursor.json"
rm -f "$CRIB_DB"

test_extraction_runs() {
  local output
  output=$("$TRICK" --file "$TRANSCRIPT" 2>&1)
  if echo "$output" | grep -q "extracted\|no memories"; then
    pass "Extraction completes without error"
  else
    fail "Extraction" "unexpected output: $output"
  fi
}
test_extraction_runs

test_memories_written_to_crib() {
  if [[ -f "$CRIB_DB" ]]; then
    local count
    count=$(/opt/homebrew/opt/sqlite/bin/sqlite3 "$CRIB_DB" "SELECT COUNT(*) FROM entries;" 2>/dev/null)
    if [[ "$count" -gt 0 ]]; then
      pass "Memories written to crib ($count entries)"
    else
      # Extraction quality varies — no memories extracted is not a failure
      pass "Extraction ran (no memories written — depends on model quality)"
    fi
  else
    # crib DB might not exist if no memories were extracted
    pass "Extraction ran (no memories extracted — depends on model quality)"
  fi
}
test_memories_written_to_crib

# ---------------------------------------------------------------------------
section "Detach mode (-d)"
# ---------------------------------------------------------------------------

test_detach_exits_immediately() {
  local start end_time elapsed
  start=$(date +%s)
  echo "{\"transcript_path\":\"$TRANSCRIPT\",\"session_id\":\"detach-test\",\"cwd\":\"$TMPDIR_BASE\"}" | "$TRICK" -d 2>/dev/null
  local exit_code=$?
  end_time=$(date +%s)
  elapsed=$((end_time - start))
  if [[ $exit_code -eq 0 && $elapsed -lt 3 ]]; then
    pass "Detach exits immediately (${elapsed}s)"
  else
    fail "Detach" "exit=$exit_code, elapsed=${elapsed}s"
  fi
}
test_detach_exits_immediately

test_detach_creates_snapshot() {
  local snapshots
  snapshots=$(ls "$TMPDIR_BASE/.claude/trick-snapshots/"*.jsonl 2>/dev/null | wc -l | tr -d ' ')
  if [[ "$snapshots" -gt 0 ]]; then
    pass "Detach creates transcript snapshot"
  else
    fail "Detach snapshot" "no snapshots found"
  fi
}
test_detach_creates_snapshot

test_detach_empty_input() {
  local exit_code
  echo "" | "$TRICK" -d 2>/dev/null
  exit_code=$?
  if [[ $exit_code -eq 0 ]]; then
    pass "Detach handles empty input"
  else
    fail "Detach empty" "expected exit 0, got $exit_code"
  fi
}
test_detach_empty_input

test_detach_missing_transcript() {
  local exit_code
  echo '{"transcript_path":"/nonexistent/file.jsonl","session_id":"x"}' | "$TRICK" -d 2>/dev/null
  exit_code=$?
  if [[ $exit_code -eq 0 ]]; then
    pass "Detach handles missing transcript"
  else
    fail "Detach missing" "expected exit 0, got $exit_code"
  fi
}
test_detach_missing_transcript

# ---------------------------------------------------------------------------
# Summary
# ---------------------------------------------------------------------------

printf "\n\033[1m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\033[0m\n"
printf "\033[1m%d passed\033[0m" "$passed"
[[ $failed -gt 0 ]] && printf ", \033[31m%d failed\033[0m" "$failed"
printf "\n"

if [[ $failed -gt 0 ]]; then
  printf "\n\033[31mFailing:\033[0m\n"
  for f in "${failures[@]}"; do
    printf "  • %s\n" "$f"
  done
  printf "\n"
  exit 1
fi

exit 0
